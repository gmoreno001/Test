---
title: "test1"
subtitle: "test test."
summary: "test test test"
date: 2021-12-30
authors:
 - admin
slug: test
#categories: ["Blogging"]
#tags: ["Blogdown", "R", "Blogging", "Markdown", "R Markdown"]
## For re-generating the md output from the original R code
#output:
#  bookdown::html_document2:
#    keep_md: yes
---

The R package [blogdown](https://bookdown.org/yihui/blogdown/) has become a widely  popular solution to setting up personal blogs. However, one problem with blogdown This may be fine if you're just starting out with your site or if your posts generally don't contain any sophisticated R code, but in a long-standing blog you'll eventually run into trouble. First, re-knitting hundreds of posts may be quite slow. And second, if you've got a bunch of old posts chances are some will not knit anymore, and then you may have got a serious problem with no simple solution.

This problem has been recognized for a while, and the proposed solution is usually to knit only on demand. See e.g. [here](https://yutani.rbind.io/post/2017-10-25-blogdown-custom/). The experimental [hugodown package](https://github.com/r-lib/hugodown) likewise aims to limit any unnecessary re-knitting. Here, I'm taking a different approach. My perspective is that I want to be able to re-knit any time without worrying that I'll destroy anything of value, and I also want to be able to add code and output to posts containing prior code that doesn't run anymore today.

```{r echo = FALSE}
knitr::opts_chunk$set(comment = "#")
# comment out to regenerate plots, output, etc.
knitr::opts_chunk$set(echo = FALSE, eval = FALSE)
```

### 1.

Blah black 

### 2. 

Next I call in several `R` packages to help with the analysis:

```{r echo=TRUE}
library(tidyverse)
library(lubridate)
library(hrbrthemes)
library(waffle)
library(ggplot2)
library(dplyr)
```

```{r echo=TRUE}
# CREATE TIME DATA FRAME  
start_date <- as.Date("2020-01-01")
end_date <- as.Date("2020-12-31")
time <- tibble(date = seq(start_date, end_date, by = "1 day")) 
time$week <- format(time$date, "%W")
time$day <- format(time$date, "%A")
time$day_n <- format(time$date, "%u") 
time$month <- format(time$date, "%B")
time$month_n <- format(time$date, "%m")
time$quarter <- quarter(time$date) 

# IMPORT ACTIVITIES DATA 
activities <- read.csv("C:/Users/John Jay REC/Downloads/activities_df.csv") #366 obs 6 vars 

# Replace DNT with 0
activities <- activities %>%
  mutate(workout_or_not = replace(workout_or_not, workout_or_not == "DNT", 0),
         mat_pt_mobility_session = replace(mat_pt_mobility_session, mat_pt_mobility_session == "DNT", 0),
         incidental_exercise = replace(incidental_exercise, incidental_exercise == "DNT", 0)) %>%
  mutate(workout_or_not = as.numeric(workout_or_not),
         mat_pt_mobility_session = as.numeric(mat_pt_mobility_session),
         incidental_exercise = as.numeric(incidental_exercise))

# CONVERT DATE 
activities$date <- as.Date(activities$date ,format = "%m/%d/%Y") 

# JOIN ACTIVITIES DATA TO TIME DATA
df <- left_join(time, activities, by = c("date")) #366 obs 12 vars

# COMPUTE SUM OF ACTIVITIES FOR EACH DAY
df <- df %>% 
  mutate(sum_workout_mobility = workout_or_not + mat_pt_mobility_session,
         sum_workout_incidental = workout_or_not + incidental_exercise, 
         sum_all = workout_or_not + mat_pt_mobility_session + incidental_exercise)
  
# CONVERT TO FACTOR WITH LABELS 
df <- df %>% mutate(quarter= factor(quarter, levels=c(1,2,3,4), 
                                    labels=c("Jan to March", "April to June", "July to Sept", "Oct to Dec")),
                    sum_all = factor(sum_all, levels = c(0,1,2,3), 
                                     labels = c("0 recorded activity", "1 activity", "2 activities", "3 activities")))

# COLLAPSE SUM OF ACTIVITIES BY QUARTER
all_quarters <- df %>% count(quarter, sum_all)
```


